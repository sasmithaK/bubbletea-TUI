package main

import (
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/charmbracelet/bubbles/progress"
	"github.com/charmbracelet/bubbles/spinner"
	"github.com/charmbracelet/bubbles/textinput"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

// --- 1. THE ARCHITECTURE (Elm Architecture) ---
// Bubble Tea is based on the Elm Architecture, which consists of three main parts:
// 1. Model:  The application state (data).
// 2. View:   A function that renders the state into a string.
// 3. Update: A function that handles events (Messages) and updates the state.

// screen is a custom type used to represent different "pages" or views in our TUI.
type screen int

// These constants represent the different screens in our application.
const (
	menuScreen screen = iota
	progressScreen
	searchScreen
	spinnerScreen // Added a spinner screen as a beginner-friendly TUI feature!
	helpScreen
)

// tickMsg is a custom "Message". Messages are events that Bubble Tea's Update function receives.
// It could be a keypress, window resize, or in this case, a clock time tick.
type tickMsg time.Time

// --- 2. THE MODEL ---
// The model struct stores the entire state of our application. All data needed to render
// the UI must be held here. It is generally a good practice to put everything in a single struct.
type model struct {
	screen    screen          // the current screen being displayed
	cursor    int             // index of the current selection in lists
	width     int             // terminal width (for responsive layouts)
	height    int             // terminal height
	progress  progress.Model  // a pre-built component for progress bars
	percent   float64         // current progress percentage
	textInput textinput.Model // a pre-built component for text inputs
	spinner   spinner.Model   // a pre-built component for loading animations
	items     []string        // complete list of searchable items
	filtered  []string        // list of items currently matching the search query
}

// initialModel is a helper function to set up the starting state of our application.
func initialModel() model {
	// Initialize the text input component.
	ti := textinput.New()
	ti.Placeholder = "Type to filter features..."
	ti.Focus()
	ti.CharLimit = 50
	ti.Width = 30

	// Initialize the progress bar component with a customizable color gradient.
	p := progress.New(progress.WithDefaultGradient())

	// Initialize the spinner component (a very common TUI feature for loading states).
	s := spinner.New()
	s.Spinner = spinner.Dot                                         // Use the specific dot animation style
	s.Style = lipgloss.NewStyle().Foreground(lipgloss.Color("205")) // Pinkish color

	// Data for our search/filter menu list
	items := []string{
		"Multi-screen Navigation",
		"Progress Bar with Ticks",
		"Spinner Loading Animation",
		"Search & Filter (TextInput)",
		"Responsive Layout",
		"Styled Components (Lipgloss)",
		"Keyboard Shortcuts",
		"State Management",
	}

	return model{
		screen:    menuScreen,
		progress:  p,
		textInput: ti,
		spinner:   s,
		items:     items,
		filtered:  items, // Initially, no filter is applied, so show all items
	}
}

// tick is a "Command" (tea.Cmd). Commands represent side-effects or asynchronous operations
// (like timers, network requests, or reading from disk). This Command produces a tickMsg every 1/20th of a second.
func tick() tea.Cmd {
	return tea.Tick(time.Second/20, func(t time.Time) tea.Msg {
		return tickMsg(t)
	})
}

// --- 3. INIT ---
// Init is called once when the program starts. It can return a Command that runs right away.
// We use this to kick off the background background timer and spinner animation!
func (m model) Init() tea.Cmd {
	return tea.Batch(
		tick(),         // Start the tick timer for the progress bar
		m.spinner.Tick, // Start the spinner's internal animation timer
	)
}

// --- 4. UPDATE ---
// Update is called whenever an event (Message) happens. It takes the message, acts on it,
// and returns an updated Model and an optional Command (if a new side effect is needed).
func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	// Let's create a slice to collect commands, since we might need to return multiple commands at once.
	var cmds []tea.Cmd

	switch msg := msg.(type) { // What type of message did we receive?

	// tea.WindowSizeMsg is sent when the terminal is resized. Catching it allows responsive UIs!
	case tea.WindowSizeMsg:
		m.width = msg.Width
		m.height = msg.Height

	// tickMsg is our custom timer message generated by the tick() Command.
	case tickMsg:
		if m.screen == progressScreen {
			m.percent += 0.005
			if m.percent > 1 {
				m.percent = 0 // Loop back to 0
			}
		}
		cmds = append(cmds, tick()) // Add the next tick Command to keep the loop going!

	// spinner.TickMsg is sent by the spinner component to animate its frames.
	case spinner.TickMsg:
		var cmd tea.Cmd
		m.spinner, cmd = m.spinner.Update(msg)
		cmds = append(cmds, cmd)

	// tea.KeyMsg is sent whenever the user presses a key.
	case tea.KeyMsg:
		switch msg.String() { // What was the actual key?

		// Global quit command
		case "ctrl+c", "q":
			return m, tea.Quit

		// Numeric keys switch between our custom "screens"
		case "1":
			m.screen = menuScreen
		case "2":
			m.screen = progressScreen
		case "3":
			m.screen = searchScreen
		case "4":
			m.screen = spinnerScreen
		case "5":
			m.screen = helpScreen

		// 'up' and 'k' move our selection cursor up (in lists)
		case "up", "k":
			if m.cursor > 0 {
				m.cursor--
			}

		// 'down' and 'j' move our selection cursor down (in lists)
		case "down", "j":
			if m.cursor < len(m.filtered)-1 {
				m.cursor++
			}
		}
	}

	// Route events to the TextInput component if we are on the search screen.
	// We handle this outside the main switch because the TextInput needs to capture ALL keypresses (like typing characters).
	if m.screen == searchScreen {
		var cmd tea.Cmd
		// Pass the message down to the child textInput bubble's Update function
		m.textInput, cmd = m.textInput.Update(msg)
		cmds = append(cmds, cmd)

		// Simple filtering logic based on the input text
		query := strings.ToLower(m.textInput.Value())
		m.filtered = nil
		for _, item := range m.items {
			if strings.Contains(strings.ToLower(item), query) {
				m.filtered = append(m.filtered, item)
			}
		}
	}

	// Return the new Model and route all collected commands to Bubble Tea using tea.Batch
	return m, tea.Batch(cmds...)
}

// --- 5. VIEW ---
// View renders the TUI to a string based strictly on the current state of the Model.
// No state changes (mutations) should ever happen here!
func (m model) View() string {
	// Lipgloss is Charm's styling library for the terminal. It's like CSS for TUIs.
	headerStyle := lipgloss.NewStyle().
		Bold(true).
		Foreground(lipgloss.Color("#00FFCC")).
		Padding(0, 1)

	boxStyle := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		Padding(1, 2).
		BorderForeground(lipgloss.Color("#00FFFF"))

	// A common responsive pattern is adding a persistent footer navigation menu
	footer := "\n\n[1] Menu  [2] Progress  [3] Search  [4] Spinner  [5] Help  [q] Quit"

	switch m.screen {

	case menuScreen:
		content := "ðŸš€ Enhanced Bubble Tea TUI\n\n"
		content += "This interface demonstrates:\n\n"
		content += "â€¢ Multi-screen architecture\n"
		content += "â€¢ Real-time tick updates\n"
		content += "â€¢ Simple animations\n"
		content += "â€¢ Search filtering\n"
		content += "â€¢ Component delegation (Bubbles)\n"
		content += "â€¢ Styled components with Lipgloss\n\n"
		content += "Press numbers to navigate."

		return boxStyle.Render(headerStyle.Render("MAIN MENU")+"\n\n"+content) + footer

	case progressScreen:
		// Render the child progress bar component
		bar := m.progress.ViewAs(m.percent)
		content := fmt.Sprintf(
			"ðŸ“Š Live Progress Demo\n\nAnimated using tea.Tick()\n\n%s\n\n%.0f%%",
			bar,
			m.percent*100,
		)
		return boxStyle.Render(headerStyle.Render("PROGRESS DEMO")+"\n\n"+content) + footer

	case searchScreen:
		content := "ðŸ” Search & Filter Demo\n\n"
		// Render the text input component
		content += m.textInput.View() + "\n\n"

		for i, item := range m.filtered {
			cursor := " " // Empty space
			if m.cursor == i {
				cursor = "â–¶" // Pointer indicates current selection
			}
			content += fmt.Sprintf("%s %s\n", cursor, item)
		}

		return boxStyle.Render(headerStyle.Render("SEARCH DEMO")+"\n\n"+content) + footer

	case spinnerScreen:
		content := "ðŸŒ€ Loading Indicator Demo\n\n"
		// Render the spinner component
		content += fmt.Sprintf(" %s Loading assets...\n\n", m.spinner.View())
		content += "Spinners are a great beginner feature to show the user\n"
		content += "that things are happening without freezing the UI.\n\n"
		content += "Powered by the github.com/charmbracelet/bubbles/spinner package!"

		return boxStyle.Render(headerStyle.Render("SPINNER DEMO")+"\n\n"+content) + footer

	case helpScreen:
		content := "ðŸ“˜ Core Concepts & Tips\n\n"
		content += "Tips & Best Practices:\n"
		content += "1. Model, Update, View: The trifecta! Keep them separate.\n"
		content += "2. Keep View Pure: Never mutate state inside the View() function.\n"
		content += "3. Avoid Blocking: The Update loop should be lightning fast.\n"
		content += "4. Use Bubbles: The Charm team provides pre-built components like\n"
		content += "   text inputs, spinners, progress bars, viewports, and tables\n"
		content += "   in the 'bubbles' repository. Use them for your projects!\n\n"
		content += "Navigation:\n"
		content += "  1-5 â†’ Switch screens\n"
		content += "  â†‘/â†“ or k/j â†’ Move cursor\n"
		content += "  q or Ctrl+C â†’ Exit"

		return boxStyle.Render(headerStyle.Render("HELP")+"\n\n"+content) + footer
	}

	return ""
}

// The entry point where everything is sewn together.
func main() {
	// Create the program with our starting model and an option to use the Alternate Screen
	// (which prevents the TUI from overwriting terminal history when it exits).
	p := tea.NewProgram(initialModel(), tea.WithAltScreen())
	if _, err := p.Run(); err != nil {
		fmt.Println("Error:", err)
		os.Exit(1)
	}
}
